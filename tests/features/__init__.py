from pathlib import Path
from typing import Literal

from pdb2sql import pdb2sql

from deeprank2.molstruct.aminoacid import AminoAcid
from deeprank2.molstruct.residue import Residue, SingleResidueVariant
from deeprank2.molstruct.structure import Chain, PDBStructure
from deeprank2.utils.buildgraph import get_residue_contact_pairs, get_structure, get_surrounding_residues
from deeprank2.utils.graph import Graph
from deeprank2.utils.parsing.pssm import parse_pssm


def _get_residue(chain: Chain, number: int) -> Residue:
    """Get the Residue from its Chain and number."""
    for residue in chain.residues:
        if residue.number == number:
            return residue
    msg = f"Not found: {number}"
    raise ValueError(msg)


def build_testgraph(  # noqa: C901
    pdb_path: str,
    detail: Literal["atom", "residue"],
    influence_radius: float,
    max_edge_length: float,
    central_res: int | None = None,
    variant: AminoAcid | None = None,
    chain_ids: str | tuple[str, str] | None = None,
) -> tuple[Graph, SingleResidueVariant | None]:
    """Creates a Graph object for feature tests.

    Args:
        pdb_path: Path of pdb file.
        detail: Type of graph to create.
        influence_radius: max distance to include in graph.
        max_edge_length: max distance to create an edge.
        central_res: Residue to center a single-chain graph around. Use None to create a 2-chain graph, or any value for a single-chain graph.
            Defaults to None.
        variant: Amino acid to use as a variant amino acid. Defaults to None.
        chain_ids: Explicitly specify which chain(s) to use. Defaults the first (two) chain(s) from the structure.

    Returns:
        Graph: As generated by Graph.build_graph
        SingleResidueVariant: returns None if central_res is None

    Raises:
        TypeError: if detail is set to anything other than 'residue' or 'atom'
    """
    pdb = pdb2sql(pdb_path)
    try:
        structure: PDBStructure = get_structure(pdb, Path(pdb_path).stem)
    finally:
        pdb._close()

    if not central_res:
        nodes = set()
        if not chain_ids:
            chains = (structure.chains[0].id, structure.chains[1].id)
        else:
            chains = [structure.get_chain(chain_id) for chain_id in chain_ids]

        for residue1, residue2 in get_residue_contact_pairs(pdb_path, structure, chains[0], chains[1], influence_radius):
            if detail == "residue":
                nodes.add(residue1)
                nodes.add(residue2)
            elif detail == "atom":
                for atom in residue1.atoms:
                    nodes.add(atom)
                for atom in residue2.atoms:
                    nodes.add(atom)
            else:
                msg = 'detail must be "atom" or "residue"'
                raise TypeError(msg)

        return Graph.build_graph(list(nodes), structure.id, max_edge_length), None

    # if central_res
    if not chain_ids:
        chain: Chain = structure.chains[0]
    else:
        chain = structure.get_chain(chain_ids)
    residue = _get_residue(chain, central_res)
    surrounding_residues = list(get_surrounding_residues(structure, residue, influence_radius))

    try:
        with open(
            f"tests/data/pssm/{structure.id}/{structure.id}.{chain.id}.pdb.pssm",
            encoding="utf-8",
        ) as f:
            chain.pssm = parse_pssm(f, chain)
    except FileNotFoundError:
        pass

    if detail == "residue":
        return Graph.build_graph(surrounding_residues, structure.id, max_edge_length), SingleResidueVariant(residue, variant)
    if detail == "atom":
        atoms = {atom for residue in surrounding_residues for atom in residue.atoms}
        return Graph.build_graph(list(atoms), structure.id, max_edge_length), SingleResidueVariant(residue, variant)
    msg = 'detail must be "atom" or "residue"'
    raise TypeError(msg)
